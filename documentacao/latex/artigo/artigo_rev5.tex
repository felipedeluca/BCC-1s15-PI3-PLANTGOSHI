\documentclass[12pt]{article}
\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage{gensymb}
%\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  
\usepackage{caption3}
\captionsetup{font=footnotesize}

\hyphenation{ algo-ritmos co-lher in-di-vi-du-al-men-te u-sa-bi-li-da-de outros}
     
\sloppy

\title{PlantGoshi\\ Projeto Integrador III - Sistema Aut\^onomo}

\author{Anderson J. Silva, Felipe R. de Luca, Nelson J. Dressler }


\address{Bacharelado em Ci\^encia da Computa\c c\~ao -- Centro Universit\'ario Senac - Santo Amaro \\
  S\~ao Paulo - SP - Brasil \\ 2015
}
\begin{document} 

\maketitle
     
\begin{resumo} 
O projeto foi desenvolvido para a disciplina Projeto Integrador III: Sistema Aut\^onomo,
com o objetivo de aplicar t\'ecnicas e implementar algoritmos de vis\~ao computacional
em um jogo de tema livre. Para tal, criamos um jogo digital em 2D, desenvolvido em linguagem C,
onde o jogador deve cuidar de uma \'arvore em seu processo de crescimento, com o objetivo
principal de colher os melhores frutos. Para isso, o jogador ter\'a como ferramenta de
intera\c c\~ao uma varinha m\'agica, que permitir\'a aplicar poderes que interajam
com os elementos dentro do jogo, contribuindo com o crescimento da \'arvore e impedindo
que pragas ataquem os frutos. A intera\c c\~ao da varinha com o jogo ser\'a por
interm\'edio do reconhecimento dela nas imagens capturadas pela c\^amera de video
instalada no computador, processadas por algoritmos baseados em levantamento bibliogr\'afico.

\end{resumo}

\section{Introdu\c c\~ao}

 O Projeto desenvolvido para a disciplina Projeto Integrador III: Sistema Aut\^onomo aborda a quest\~ao sobre
 educa\c c\~ao ambiental. O jogador tem tr\^es minutos para cuidar de uma \'arvore, desde seu crescimento
 at\'e o amadurecimento e colhimento dos frutos. Durante a partida, o jogador dever\'a estar sempre atento
 \`a falta de \'agua e pragas que surgir\~ao para comer os frutos.
   
 O desafio do projeto consiste em estudar, desenvolver e implementar algoritmos de vis\~ao computacional 
 para processamento de imagens, com a finalidade de promover a intera\c c\~ao do jogador com o jogo. Essa
 intera\c c\~ao dever\'a ocorrer exclusivamente atrav\'es da c\^amera de video acoplada ao computador. O jogador
 ter\'a \`a sua disposi\c c\~ao uma varinha m\'agica com uma luz de LED na ponta, que ser\'a reconhecida pelos algoritmos
 e seus movimentos traduzidos como coordenadas de posi\c c\~ao X e Y dentro do jogo. Basicamente a varinha tem
 o funcionamento de um mouse.   
  
\section{O jogo}

 Para vencer os desafios, o jogador tem \`a sua disposi\c c\~ao quatro tipos de poderes especiais: Poder de Regar,
 Poder de Remover Pragas, Poder de Colher Frutos e Poder da M\'usica. Cada um desses poderes tem uma fun\c c\~ao
 diferente no jogo e devem ser utilizadas com cautela, pois quando acionado um desses poderes, os restantes ficar\~ao
 indispon\'iveis por alguns segundos. N\~ao \'e poss\'ivel utilizar mais de um poder por vez.

 O jogador tem a op\c c\~ao de mudar manualmente durante a partida a cor reconhecida do objeto usado para interagir com o jogo.
 Basta selecionar os n\'umeros de 1-6 e o jogo ir\'a reconhecer a nova cor. As op\c c\~oes poss\'iveis de cor s\~ao as
 seguintes:
 
 \begin{enumerate}
 	\item Amarelo
 	\item Verde
 	\item Ciano
 	\item Azul
 	\item Magenta
 	\item Vermelho
 \end{enumerate}
 
 \subsection{Poderes}
 \subsubsection{Poder de Regar} 
 Com Poder de Regar o jogador garante que a \'arvore ir\'a crescer mais e consequentemente ir\'a
 dar mais frutos. \'E necess\'ario estar sempre atento \`a barra de n\'ivel de \'agua. Nunca regue demais a
 \'arvore e tamb\'em n\~ao a deixe sem \'agua.
 
	\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=1.1]{img/icone_gota.png}
		\footnotesize \caption{Poder de Regar }
	\end{center}
	\end{figure}	
  
 \subsubsection{Poder de Remover Pragas}
 O Poder de Remover Pragas auxilia o jogador a retirar bichos que nascem, evitando assim
 que os frutos sejam comidos. O jogador tem um tempo curto para remover essas pragas, antes que
 elas danifiquem os frutos e a \'arvore.

	\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=1.1]{img/icone_luva.png}
		\footnotesize \caption{Poder de Remover Pragas }
	\end{center}
	\end{figure}	
 
 \subsubsection{Poder da M\'usica}
 O poder da m\'usica auxilia no amadurecimento mais r\'apido dos frutos. O jogador aplica diretamente esse poder em cima
 do fruto que deseja.
 
	\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=1.1]{img/icone_nota_musical.png}
		\footnotesize \caption{Poder da M\'usica}
	\end{center}
	\end{figure}	

 \subsubsection{Poder de Colher}
 A pontua\c c\~ao final da partida do jogo est\'a diretamente ligada ao Poder de Colher. Existe um momento ideal para colher o
 fruto, que \'e quando ele est\'a vermelho e saud\'avel. Caso seja colhido antes da hora ou depois, o jogador perder\'a
 pontos. Muita aten\c c\~ao caso o fruto esteja com praga. Se isso ocorrer, ser\'a necess\'ario remov\^e-la antes de
 colher o fruto.
 
	\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=1.1]{img/icone_cesta.png}
		\footnotesize \caption{Poder de Colher}
	\end{center}
	\end{figure}	

 \subsection{Varinha m\'agica}
 Com a varinha m\'agica o jogador poder\'a interagir com os elementos dentro do jogo como sele\c c\~ao de poderes, regar e remo\c c\~ao
 de pragas. Ao selecionar um poder a luz na ponta da varinha ir\'a assumir a cor desse poder, indicando que ele foi selecionado e est\'a ativo.
 Se n\~ao houver luz, significa que a sele\c c\~ao de poderes est\'a desabilitada temporariamente. Caso a luz seja a cor branco, ent\~ao
 est\'a dispon\'ivel selecionar qualquer poder.
 
 Para interagir com o jogo, basta mover a varinha em frente \'a tela do computador e um cursor na tela ir\'a indicar qual a posi\c c\~ao
 atual da varinha dentro do jogo. Para selecionar o poder desejado, \'e necess\'ario posicionar o cursor por dois segundos em cima desse poder.
 O poder foi selecionado quando a luz na ponta da varinha mudar de cor. 

	\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=0.45]{img/varinha.png}
		\footnotesize \caption{Varinha m\'agica com LED na ponta.}
	\end{center}
	\end{figure}	

\subsection{Layout}

	\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=0.3]{img/tela2_jogo.png}
		\footnotesize \caption{Primeira vers\~ao da tela do jogo. Os gr\'aficos ser\~ao alterados para a vers\~ao final do jogo.}
	\end{center}
	\end{figure}	

\subsection{Etapas}
A partida do jogo \'e dividida em tr\^es principais etapas: 

\begin{enumerate}
\item \textbf{Nascimento e Crescimento da \'Arvore:} o jogador dever\'a estar atento a regar a \'arvore sempre que
necess\'ario e, ao mesmo tempo, combater ervas daninhas que ir\~ao crescer ao p\'e dela.
\item \textbf{Amadurecimento dos Frutos:} os frutos ir\~ao crescer mais r\'apido se o jogador utilizar notas musicais.
Tamb\'em ir\~ao crescer pragas nesses frutos, que podem ser combatidas com o poder de remo\c c\~ao de pragas.
\item \textbf{Colhimento dos Frutos:} \'e o momento no qual os frutos cresceram e amadureceram
 o suficiente para serem colhidos, contabilizando pontos para o jogador.
\end{enumerate}

\section{Vis\~ao Computacional}

Compreendendo a parte de vis\~ao computacional, foi realizado um levantamento bibliogr\'afico
referente ao processamento digital de imagens, reconhecimento de padr\~oes em imagens, opera\c c\~oes
aritm\'eticas e um estudo aprofundado sobre os modelos de cores, sua natureza e suas caracter\'isticas principais.

\subsection{Algoritmos utilizados\label{sec:alg}}
\subsubsection{HSV e RGB}
Escolhemos analisar e processar as imagens capturadas pela c\^amera de video utilizando o espa\c co de cor
HSV. Essa escolha levou em considera\c c\~ao o fato de que trabalhar puramente com o RGB n\~ao seria poss\'ivel
separar a cor da lumin\^ancia e da satura\c c\~ao. Essa separa\c c\~ao \'e essencial para que haja identifica\c c\~ao 
de diferentes objetos na imagem com a mesma cor, mas que  tenham lumin\^ancia e satura\c c\~ao diferentes. Com isso,
\'e poss\'ivel isolar o objeto utilizado para intera\c c\~ao com o jogo dos demais objetos.

Cada pixel de uma imagem extra\'ida da c\^amera do computador no modelo de cores RGB (Red, Green, Blue) \'e convertido em
HSV / HSB (Hue, Saturation, Value / Brightness), permitindo descobrir o grau da cor pura (Matiz), as faixas representada por cada cor,
a porcentagem de satura\c c\~ao da cor (Pureza) e a porcentagem de brilho (Valor).

O H \'e a matiz e \'e medida em graus compreendendo valores de 0\degree a 359\degree.
A faixa de cada uma das seis cores principais (prim\'arias e secund\'arias) \'e definida numa margem de 60 graus.
As faixas s\~ao classificadas da seguinte maneira: Vermelho (0\degree a 59\degree), Amarelo (60\degree a 119\degree), Verde (120\degree a 179\degree),
Ciano (180\degree a 239\degree), Azul (240\degree a 299\degree) e Magenta (300\degree a 359\degree).
O S \'e a satura\c c\~ao e \'e medida em porcentagem nos valores de 0 a 100\%.
Finalmente, o V \'e o brilho e medido tamb\'em em porcentagem, (0 a 100\%). Como observa\c c\~ao importante, \'e poss√≠vel notar
que as cores branco e preto s\~ao definidas de acordo com o valor de V: quando se aproxima de 0, emite a cor preta,
e quando se aproxima de 100, branca.

Por exemplo, para reconhecer a luz do LED, \'e poss\'ivel por interm\'edio de uma porcentagem alta
do V (Valor de brilho) e sua cor pela faixa de H (Matiz).

Para manipular essa representa\c c\~ao, foi necess\'ario a cria\c c\~ao de uma estrutura chamada Pixel
que deve armazenar todos os dados de cores de apenas um pixel e a implementa\c c\~ao de dois algoritmos
que compreendem as convers\~oes nos dois sentidos: RGB para HSV e HSV para RGB.

A fim de padronizar, foram implementadas tamb\'em algumas fun\c c\~oes de formata\c c\~ao: convers\~ao de
um valor decimal para porcentagem (S e V), convers\~ao de um grau para um valor de 0 a 5 (H) e convers\~ao
de canais de cores RGB em um valor decimal entre 0 e 1.

Al\'em disso, foram desenvolvidas fun\c c\~oes complementares de m\'aximo e m\'inimo dentre tr\^es valores (R, G e B).

	\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=0.12]{img/HSV_color_solid_cylinder_alpha_lowgamma.png}
		\footnotesize \caption{Representa\c c\~ao tridimensional do espa\c co de cor HSV. Cr\'editos: SharkD. http://en.wikipedia.org/wiki/HSL\_and\_HSV }
	\end{center}
	\end{figure}	

\subsubsection{Escala de cinza / lumin\^ancia}
Os valores RGB de um pixel podem ser convertidos em escala de cinza por uma s\'erie de m\'etodos.
Com esse fim, foi escolhido o m\'etodo de extra\c c\~ao de lumin\^ancia Y dos canais RGB.
\'E efetuada a seguinte opera\c c\~ao sobre cada pixel:

\texttt{\small \textbf{Y} = \textbf{R} x 0.299 + \textbf{G} x 0.587 + \textbf{B} x 0.114}

\noindent Dessa maneira, \'e obtida a lumin\^ancia da imagem separada das cores.

	\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=0.7]{img/1200px-Beyoglu_4671_tricolor.png}
		\footnotesize \caption{Convers\~ao de cada canal de cor para sua respectiva escala de cinza. Cr\'editos: Nevit Dilmen. http://en.wikipedia.org/wiki/Grayscale }
	\end{center}
	\end{figure}	

\subsubsection{Centro de massa}
Visando uma defini\c c\~ao exata e correta do ponto central que deve ser devolvido pela fun\c c\~ao da vis\~ao computacional,
foi necess\'ario a implementa\c c\~ao de um mecanismo para obter o centro de massa do maior aglomerado de pixels (clusters) presentes
na imagem. Com o valor do centro de massa obtido, \'e poss\'ivel retornar as coordenadas \texttt{x} e \texttt{y} desse centro e utilizar como
coordenadas de um dispositivo mouse.

Para calcular o centro de massa, \'e necess\'ario fornecer uma matriz onde os valores dos pixels s\~ao 0 ou maior.
Quando o pixel for maior do que 0, \'e somado +1 ao valor presente em cada uma das vari\'aveis que contabilizam a
soma total de pixels nos eixos \texttt{x} e \texttt{y}. Paralelamente existe outra vari\'avel que contabiliza o total de pixels
encontrados com valor maior do que 0:


\noindent \texttt{\footnotesize{ \textbf{REPETIR ENQUANTO} i \textbf{<} imagem.altura; i = i + 1} }

\hspace{0.2cm} \texttt{\footnotesize{ \textbf{REPETIR ENQUANTO} j \textbf{<} imagem.largura; j = j + 1}}

\hspace{0.4cm} \texttt{\footnotesize{ \textbf{SE O VALOR} matriz[ i ][ j ] > 0 \textbf{ENT\~AO} }}

\hspace{0.6cm} \texttt{\footnotesize{ centroMassa.y = centroMassa.x + i}}

\hspace{0.6cm} \texttt{\footnotesize{ centroMassa.x = centroMassa.y + j}}

\hspace{0.6cm} \texttt{\footnotesize{ centroMassa.total = centroMassa.total + 1}}\\


\noindent O c\'alculo final das coordenadas \texttt{x} e \texttt{y} do centro de massa \'e realizado da seguinte forma:\\

\hspace{0.4cm} \texttt{\footnotesize{ \textbf{SE O VALOR} centroMassa.total \textbf{ENT\~AO} }}

\hspace{0.6cm} \texttt{\footnotesize{ y = centroMassa.y / centroMassa.total}}

\hspace{0.6cm} \texttt{\footnotesize{ x = centroMassa.x / centroMassa.total}}

\hspace{0.4cm} \texttt{\footnotesize{ \textbf{SEN\~AO}}}

\hspace{0.6cm} \texttt{\footnotesize{ y = -1}}

\hspace{0.6cm} \texttt{\footnotesize{ x = -1}}

	\begin{figure}[ht!]
		\begin{center}
			\includegraphics[scale=0.7]{img/centromassa.png}
			\footnotesize \caption{Centro de massa representado pelo c\'irculo}
		\end{center}
	\end{figure}	


\subsubsection{Redu\c c\~ao de cores}
A redu\c c\~ao de cores \'e uma t\'ecnica que tem por objetivo facilitar o reconhecimento de uma regi\~ao espec\'ifica,
diminuindo as cores vis\'iveis e tornando uma regi\~ao mais destacada e isolada que as demais.
Para tal, \'e usada a seguinte opera\c c\~ao sobre cada canal RGB:

\texttt{\small canal.vermelho = (vermelho / Fator ) * Fator}

\texttt{\small canal.verde = (verde / Fator ) * Fator}

\texttt{\small canal.azul = (azul / Fator ) * Fator}
\vspace{0.5cm}

\noindent Considerando que o fator \'e um valor inteiro que define a propor\c c\~ao da quantidade cores que se quer diminuir na imagem.
Exemplos de Fatores: 2, 16, 64, 128. Quanto maior o fator, menor a quantidade de cores vis\'iveis.

	\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=0.3]{img/kmeansout.png}
		\footnotesize \caption{Redu\c c\~ao da quantidade de cores de acordo com valor do par\^ametro K. Fonte: http://opencvpython.blogspot.com.br/2013/01/k-means-clustering-3-working-with-opencv.html }
	\end{center}
	\end{figure}	

\subsubsection{Eros\~ao e dilata\c c\~ao}
A Eros\~ao e a Dilata\c c\~ao s\~ao t\'ecnicas de filtragem com o objetivo de reduzir ru\'idos presentes na imagem,
que possam dificultar a detec\c c\~ao de pontos principais na tela.

Os ru\'idos podem ser causados por uma s\'erie de fatores, dentre eles limita\c c\~oes da c\^amera presente no computador
e presen\c ca de pontos isolados na tela que tenham caracter\'isticas similares aos procurados.

A Eros\~ao trata de eliminar os pontos isolados na imagem, os quais n\~ao possuem outros em destaque em sua vizinhan\c ca.

A Dilata\c c\~ao trata de aumentar os pontos isolados na imagem, consistindo no processo contr\'ario da Eros\~ao.

Com uma sequ\^encia razo\'avel de opera\c c\~oes de Eros\~ao e Dilata\c c\~ao, a quantidade de ru\'idos \'e descartada,
ao mesmo passo que a regi\~ao que deve ser destacada \'e mantida em seu tamanho original.

	\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=0.3]{img/erodeDilate.png}
		\footnotesize \caption{Esquerda: Imagem original. Meio: eros\~ao. Direita: dilata\c c\~ao. Fonte: http://visiblevisible.org/teaching/setpixel/students/katherine/images/erodeDilate.png }
	\end{center}
	\end{figure}	
\newpage
\subsubsection{Filtro de m\'edia de pixels}
O filtro que processa a m\'edia entre os pixels \'e conhecido como filtro do tipo espacial,
ou seja, uma regi\~ao de pixels \'e avaliada e processada.

A principal utiliza\c c\~ao do filtro de m\'edia de pixels \'e suavizar a imagem e reduzir
ru\'idos provocados pela compress\~ao da imagem e tamb\'em por outros fatores, entre
eles a qualidade da c\^amera.

O c\'alculo deste filtro \'e bem simples e consiste em somar os valores de todos os
pixels dentro de uma matriz, que geralmente \'e de tamanho 3x3, para depois dividir
o resultado da soma pelo n\'umero de elementos na matriz. O valor obtido \'e ent\~ao atribu\'ido
ao pixel do centro dessa matriz, conforme exemplo abaixo: \\
\begin{center}
\begin{tabular}{ccc}
	\begin{tabular}{|c|c|c|}
	\hline 
	120 & 10 & 246 \\ 
	\hline 
	200 & 16 & 100 \\ 
	\hline 
	230 & 83 & 215 \\ 
	\hline 
	\end{tabular} 
& $\rightarrow$ &
	\begin{tabular}{|c|c|c|}
	\hline 
	120 & 10 & 246 \\ 
	\hline 
	200 & \textbf{135} & 100 \\ 
	\hline 
	230 & 83 & 215 \\ 
	\hline 
	\end{tabular} 

\end{tabular}
\end{center}

\vspace{0.5cm}

Para o desenvolvimento deste projeto foi aplicada uma matriz de tamanho 7x7 individualmente para cada canal
de cor RGB, o que resultou em uma imagem bem suavizada e eliminou a maioria dos ru\'idos provocados pela compress\~ao dos
frames de video produzidos pela c\^amera de captura.

	\begin{figure}[ht!]
		\begin{center}
			\includegraphics[scale=0.6]{img/exemplo_meanfilter.png}
			\footnotesize \caption{Esquerda: imagem com ru\'ido. Direita: imagem ap\'os aplica\c c\~ao do filtro. Fonte: http://lodev.org/cgtutor/filtering.html }
		\end{center}
	\end{figure}	
\newpage

\subsubsection{Redu\c c\~ao de escala}
Cada c\^amera de video captura a imagem em resolu\c c\~oes diferentes. Isso \'e um problema quando n\~ao h\'a
meios de configurar a resolu\c c\~ao de captura da imagem antes de iniciar o jogo, pois o processamento da imagem
varia de acordo com o computador utilizado. Para evitar esse tipo de problema e possibilitar que os algoritmos implementados
trabalhassem de forma eficiente, empregou-se uma t\'ecnica bem simples para reduzir
o tamanho da imagem capturada para um tamanho pequeno e fixo.
 
Adotou-se como padr\~ao a dimens\~ao 320 x 240 que proporciona duas vantagens: menos mem\'oria RAM consumida
 e menor tempo de processamento:

\noindent \texttt{\footnotesize{ \textbf{REPETIR ENQUANTO} y \textbf{<} imagem.altura \textbf{/} 240; y = y + 1} }

\hspace{0.2cm} \texttt{\footnotesize{ \textbf{REPETIR ENQUANTO} x \textbf{<} (imagem.largura - 1) \textbf{/} 320; x = x + 1}}

\hspace{0.4cm} \texttt{\footnotesize{ escala.x = x * 320}}

\hspace{0.4cm} \texttt{\footnotesize{ escala.y = y * 240}}

\hspace{0.4cm} \texttt{\footnotesize{ imagem[ escala.y ][ escala.x ] = pixel.valor}}
%\vspace{0.5cm}

\subsubsection{Calibra\c c\~ao de cores}
Com o intuito de promover mais op\c c\~oes de cores para interagirem com o jogo, foi implementado um
algoritmo para calibrar as cores de acordo com o ambiente em que o jogador est\'a. Ele utiliza as t\'ecnicas
descritas para ajustar as cores a cada \emph{frame}.

Para calibrar o jogador deve centralizar dentro do quadrado vermelho o objeto com a cor. O algoritmo detecta a cor
e inicia uma compara\c c\~ao entre a quantidade de pixels dentro do quadrado e fora. S\~ao realizados ajustes autom\'aticos
de lumin\^ancia, matiz e satura\c c\~ao, at\'e que a quantidade de pixels internos seja pelo menos 300 pixels e externos menos do que 150.

A lumin\^ancia \'e ajustada de uma forma particular: calcula os m\'inimos e m\'aximos do objeto situado dentro do quadrado.

	\begin{figure}[ht!]
		\begin{center}
			\includegraphics[scale=0.3]{img/calibracor.png}
			\footnotesize \caption{Processo de calibra\c c\~ao da cor }
		\end{center}
	\end{figure}	

A configura\c c\~ao da cor \'e salva em arquivo no disco r\'igido ap\'os terminado o processo e \'e utilizada durante a partida do jogo.

\subsection{Primeiros experimentos}
Para o reconhecimento de uma cor emitida por um LED do Arduino, fizemos uma otimiza\c c\~ao f\'isica
com um peda\c co de papel que reduzisse o brilho da luz, por\'em ainda n\~ao \'e suficiente para
o reconhecimento total.

Como experimentos necess\'arios, temos o reconhecimento da luminosidade para verificar
a proximidade da luz com a c\^amera e uma otimiza\c c\~ao afim de isolar a cor do LED,
ignorando as outras cores similares e aparentes na c\^amera.

\subsection{Aplica\c c\~ao dos algoritmos}
Utilizando os algoritmos descritos em \textbf{~\ref{sec:alg}}, foi criada uma biblioteca de vis\~ao computacional que aplica cada um desses
algoritmos para retirar informa\c c\~oes sobre os pixels da imagem a cada \emph{frame} de video.

Inicialmente o jogador tem a op\c c\~ao de calibrar as cores amarelo, verde, vermelho, azul e magenta antes de iniciar o jogo.

Primeiro, \'e reduzido o tamanho da imagem capturada pela c\^amera de video para as dimens\~oes 320 x 240.
Em seguida \'e aplicado o filtro de m\'edia, que reduz ru\'idos na imagem e as informa\c c\~oes salvas na matriz \texttt{matrizMedia}.
Cada canal de cor de cada pixel dessa matriz \'e armazenado em dois tipos distintos de vari\'aveis sendo uma para cor reduzida
e a outra para a cor atual do pixel:

\texttt{\footnotesize{pR = \textbf{redu\c c\~ao}( matrizMedia[ y ][ x ].vermelho )}}

\texttt{\footnotesize{pG = \textbf{redu\c c\~ao}( matrizMedia[ y ][ x ].verde )}}

\texttt{\footnotesize{pB = \textbf{redu\c c\~ao}( matrizMedia[ y ][ x ].azul )}}

\vspace{0.5cm}

\texttt{\footnotesize{mR = matrizMedia[ y ][ x ].vermelho}}

\texttt{\footnotesize{mG = matrizMedia[ y ][ x ].verde}}

\texttt{\footnotesize{mB = matrizMedia[ y ][ x ].azul}}


A lumin\^ancia \emph{Y} \'e extra\'ida a partir das vari\'aveis \texttt{mR, mG} e \texttt{mB}.

Ambos os conjuntos \texttt{mR, mG, mB} e \texttt{pR, pG, pB} s\~ao submetidos ao processo de convers\~ao HSV que retornar\'a
para o conjunto \texttt{pR, pG, pB} os valores \texttt{pH, pS, pV} e para o conjunto {pR, pG, pB} os valores \texttt{mH, mS, mV}.

Ap\'os o processo de convers\~ao HSV, essas vari\'aveis s\~ao comparadas com a cor calibrada e, caso haja equival\^encia,
o valor 255 \'e salvo na \texttt{matrizProcessada} e 0, caso contr\'ario:

\noindent \texttt{\footnotesize{ \textbf{SE OS VALORES}} {pH >= corCalibrada.hInicio}
 \footnotesize{\textbf{E}} \footnotesize{pH <= corCalibrada.hFim} \footnotesize{\textbf{OU}}
  \footnotesize{mS >= corCalibrada.sInicio} \footnotesize{\textbf{E}} \footnotesize{mS <= corCalibrada.sFim}
   \footnotesize{\textbf{E}} \footnotesize{Y >= corCalibrada.yInicio} \footnotesize{\textbf{E}}
    \footnotesize{Y <= corCalibrada.yFim} {\textbf{ENT\~AO}}}

\hspace{0.3cm} \texttt{\footnotesize{ matrizProcessada[ y ][ x ] = 255}}

\hspace{0.1cm} \texttt{\footnotesize{ \textbf{SEN\~AO}}}

\hspace{0.3cm} \texttt{\footnotesize{ matrizProcessada[ y ][ x ] = 0}}


Em seguida \'e calculado o centro de massa na \texttt{matrizProcessada} e s\~ao retornadas as coordenadas \texttt{x} e \texttt{y}
que ser\~ao utilizadas para mover o cursor do mouse dentro do jogo.

\section{Simula\c c\~ao da \'arvore}

Adotamos a estrutura de dados de \'arvore tern\'aria para construir a \'arvore do jogo. Essa estrutura \'e basicamente constituida
em pontos de crescimento que se dividem no m\'aximo em tr\^es partes cada um. Essas partes d\~ao origem aos galhos que crescem at\'e
determinado tamanho, decidido aleat\'oriamente. As pontas de cada galho s\~ao novos pontos de crescimento,
que se dividem de novo e d\~ao origem a novos galhos

Para que simula\c c\~ao tenha um aspecto e comportamento mais pr\'oximo de uma \'arvore, elaboramos uma solu\c c\~ao que inclui
a mat\'eria estudada na disciplina de Estrutura de Dados e elaboramos algoritmos para simular o crescimento da \'arvore,
dos galhos e dos frutos. Basicamente a \'arvore cresce de acordo com um valor de energia de crescimento fornecida
a ela logo no in\'icio do jogo. Uma parte dessa energia \'e consumida pelo tronco e o restante \'e distribuido
de maneira aleat\'oria para os pr\'oximos galhos que ir\~ao nascer, de acordo com o seguinte crit\'erio: \\

 \texttt{\footnotesize{\textbf{SE} galho.energiaConsumida == ((galho.energiaLimite * 50) / 100) \textbf{E} galho.temFilhos == FALSO 
        \textbf{ENT\~AO} galho.criarFilhos = SIM}} \\


Isso se repete at\'e que n\~ao haja mais energia suficiente
para repassar ao galho seguinte. O jogador tem a oportunidade de fornecer mais energia ao longo da partida, o que
ir\'a proporcionar uma \'arvore mais desenvolvida e com mais frutos para serem colhidos.

	\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=0.2]{img/PI3_Ponto_Crescimento.png}
		\caption{\footnotesize {Crescimento dos galhos e energia transferida de pai para filho.} }
	\end{center}
	\end{figure}	
	
\subsubsection{Crescimento}
Para que os galhos crescam controladamente mas mantendo certa diferencia\c c\~ao em tamanho e
dire\c c\~ao entre um e outro, estabelecemos um crit\'erio que chamamos de energia de crescimento e energia limite.
A energia limite determina o quanto cada  galho da \'arvore vai crescer e \'e estabelecido atrav\'es de uma porcentagem,
calculada a partir do total de energia de crescimento fornecida para o galho, o n\'ivel de altura desse galho e a energia
limite da \'arvore:

  \texttt{\footnotesize{galho.energiaLimite = (energiaRecebida * (arvore.energiaLimite - (galho.profundidade * 2)) / 100)}}

O valor da energia limite pode
ser alterado de acordo com a intera\c c\~ao do usu\'ario ao longo do jogo, o que pode proporcionar uma \'arvore mais
mais ou menos desenvolvida.

Enquanto os galhos crescem eles podem dar origem a novos galhos. Isso \'e determinado ap\'os ser consumida uma determinada
quantidade de energia de crescimento fornecida ao galho, o que permite que a simula\c c\~ao de crescimento da \'arvore
fique mais natural. A \'unica exce\c c\~ao \'e o tronco da \'arvore, que tem o crescimento
mais controlado:

\texttt{\footnotesize{\textbf{SE} galho.energiaConsumida < galho.energiaLimite \textbf{E} galho.energiaRecebida > 0
\textbf{ENT\~AO} galho.crescer}}

\subsubsection{Pontos de crescimento de frutos e folhas}
Os pontos de crescimento de frutos e folhas s\~ao determinados de acordo com o m\'inimo de energia que o galho
tem para crescer. Caso esse valor seja igual ou abaixo de determinado crit\'erio, o algoritmo de simula\c c\~ao assume
que n\~ao ir\~ao surgir novos galhos a partir do galho atual, ainda durante a fase de crescimento. Com isso determinado,
o galho passa a produzir folhas e frutos ao inv\'es de novas ramifica\c c\~ao de galhos.

	\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=0.15]{img/PI3_Arvore.png}
		\footnotesize \caption{Estrutura da \'arvore e pontos de crescimento de frutos e folhas }
	\end{center}
	\end{figure}	
\newpage
\section{Bibliotecas}
\subsection{OpenCV 2.4.11}
OpenCV (Open Source Computer Vision Library)
\'e uma biblioteca de c\'odigo aberto de vis\~ao computacional e aprendizado de m\'aquina,
desenvolvida para dar suporte a aplicativos que requerem processamento de imagens.
  
\subsection{Allegro 5.0}
O Allegro \'e uma biblioteca multiplataforma de programa\c c\~ao voltada para desenvolvimento de jogos. Ela
oferece suporte para programa\c c\~ao baixo n\'ivel em C e C++, ou seja, fornece ferramentas para que o usu\'ario
desenvolva sua pr\'opria programa\c c\~ao de jogo.
\subsection{Arduino-Serial}
Biblioteca de c\'odigo aberto em linguagem de programa\c c\~ao C, que oferece suporte a
comunica\c c\~ao via porta serial do computador com o Arduino.

\subsection{Linguagens de programa\c c\~ao}
O projeto inteiro foi desenvolvido em linguagem C padr\~ao c99.

\section{Equipamentos}
\begin{itemize}
\item C\^amera de captura de v\'ideo
\item Placa controladora Arduino Uno
\item LED RGB
\item Computador (desktop ou notebook)
\end{itemize}

\section{Resultados e conclus\~ao}
O estudo de t\'ecnicas em vis\~ao computacional proporciona novas alternativas em usabilidade e
interface usu\'ario/m\'aquina. Al\'em de contribuir muito ao aprendizado em desenvolver novas
solu\c c\~oes tecnol\'ogicas e fortalecendo a habilidade em criar algoritmos cada vez mais sofisticados e robustos.

Um dos principais desafios para a realiza\c c\~ao desse projeto foi a integra\c c\~ao da vis\~ao
computacional com o processamento gr\'afico do jogo, de modo que, fosse poss\'ivel obter efici\^encia
e uma jogabilidade razo\'avel para o jogador, ao mesmo tempo que, deve haver o processamento gr\'afico do jogo e da vis\~ao.

Outro desafio que enfrentamos foi a cria\c c\~ao de um algortimo que simulasse o crescimento
da \'arvore de forma aleat\'oria e que recebesse devidamente as intera\c c\~oes do usu\'ario.

Como melhorias para o projeto, \'e poss\'ivel desenvolver mecanismos de calibra\c c\~ao
e detec\c c\~ao para outras cores e uma intera\c c\~ao maior do arduino com o jogo, atribuindo uma
cor luminosa, pr\'e-determinada pelo usu\'ario, para cada \'icone ou poder espec\'ifico.

Analisando os resultados obtidos com o uso de um arquivo de configura\c c\~ao para a 
calibra\c c\~ao das cores, \'e poss\'ivel afirmar que o mesmo m\'etodo pode ser aplicado em
outros projetos relacionados \`a vis\~ao computacional, tornando a implementa\c c\~ao do programa mais modularizada e organizada.

\nocite{*}

\section{Bibliografia}
\bibliographystyle{sbc}
\bibliography{plantgoshi}


\end{document}
