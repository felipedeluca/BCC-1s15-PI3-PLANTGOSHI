\documentclass[12pt]{article}
\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage{gensymb}
%\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  
\usepackage{caption3}
\captionsetup{font=footnotesize}

\hyphenation{ algo-ritmos co-lher}
     
\sloppy

\title{PlantGoshi\\ Projeto Integrador III - Sistema Aut\^onomo}

\author{Anderson J. Silva, Felipe R. de Luca, Nelson J. Dressler }


\address{Bacharelado em Ci\^encia da Computa\c c\~ao -- Centro Universit\'ario Senac - Santo Amaro \\
  S\~ao Paulo - SP - Brasil \\ 2015
}
\begin{document} 

\maketitle
     
\begin{resumo} 
O projeto foi desenvolvido para a disciplina Projeto Integrador III: Sistema Aut\^onomo,
com o objetivo de aplicar t\'ecnicas e implementar algoritmos de vis\~ao computacional
em um jogo de tema livre. Para tal, criamos um jogo digital em 2D, desenvolvido em linguagem C,
onde o jogador deve cuidar de uma \'arvore em seu processo de crescimento, com o objetivo
principal de colher os melhores frutos. Para isso, o jogador ter\'a como ferramenta de
intera\c c\~ao uma varinha m\'agica, que permitir\'a aplicar poderes que interajam
com os elementos dentro do jogo, contribuindo com o crescimento da \'arvore e impedindo
que pragas ataquem os frutos. A intera\c c\~ao da varinha com o jogo ser\'a por
interm\'edio do reconhecimento dela nas imagens capturadas pela c\^amera de video
instalada no computador, processadas por algoritmos baseados em levantamento bibliogr\'afico.

\end{resumo}

\section{Introdu\c c\~ao}

 O Projeto consiste num jogo de simula\c c\~ao de cria\c c\~ao
 de plantas e do seu cuidado contra a presen\c ca de invasores e/ou criaturas nocivas \`a sua
 sobreviv\^encia no seu habitat natural, a terra.
 O jogador ter\'a poderes por interm\'edio de uma varinha m\'agica e, ao longo do jogo, dever\'a utiliz\'a- los para alimentar e
 aprimorar a planta ou a \'arvore e tamb\'em combater as pragas aparentes atrav\'es
 de intera\c c\~ao com diferentes cores emitidas pelo LED.
 

 Os frutos nascem verdes em pontos rand\^omicos e demoram um tempo x para seguir para a segunda etapa.
 Se o fruto no estado verde n\~o for "regado" (ou, poder de música) depois de um tempo determinado,
 ele vai ficar maduro com praga ou ficar\'a estragado. Isso for\c ca o usu\'ario a usar o poder de "regar"
 (ou, poder de m\'usica) no fruto.
 
 Quando o fruto fica maduro, depois de um tempo x ele cria praga, for\c cando o usu\'ario a usar o poder
 de "remover" para eliminar a praga do fruto maduro. 
 
 Com o fruto maduro e sem praga o usu\'ario poder\'a usar o poder de  "colher" para  colher o fruto e somar pontos. 
 Se o usu\'ario colher fruto verde, maduro com praga ou estragado ele perde pontos.
 Caso deixe o fruto estragar tamb\'em pontos s\~ao descontados. Depois que uma quantidade x de frutos estragar
 o jogo termina.
 
\section{Estrutura principal do jogo}

\subsection{Layout}
[SCREENSHOT DA TELA]

\subsection{Etapas}
A partida do jogo \'e dividida em tr\^es principais etapas: 

\begin{enumerate}
\item \textbf{Nascimento e Crescimento da \'Arvore:} o jogador dever\'a estar atento a regar a \'arvore sempre que
necess\'ario e, ao mesmo tempo, combater ervas daninhas que ir\~ao crescer ao p\'e dela.
\item \textbf{Amadurecimento dos Frutos:} os frutos ir\~ao crescer mais r\'apido se o jogador utilizar notas musicais.
Tamb\'em ir\~ao crescer pragas nesses frutos, que podem ser combatidas com o poder de remo\c c\~ao de pragas.
\item \textbf{Colhimento dos Frutos:} \'e o momento no qual os frutos cresceram e amadureceram
 o suficiente para serem colhidos, contabilizando pontos para o jogador.
\end{enumerate}

\section{Vis\~ao Computacional}

Compreendendo a parte de vis\~ao computacional, foi realizado um levantamento bibliogr\'afico
referente ao processamento digital de imagens, reconhecimento de padr\~oes em imagens, opera\c c\~oes
aritm\'eticas e um estudo aprofundado sobre os modelos de cores, sua natureza e suas caracter\'isticas principais.

\subsection{Metodologia geral}
Com base nos algoritmos descritos em \textbf{~\ref{sec:alg}} , foi criada uma fun\c c\~ao de vis\~ao computacional que aplica cada um desses
algoritmos para retirar informa\c c\~oes sobre os pixels da imagem.

Primeiro, o canal RGB \'e convertido em HSV antes e ap\'os a aplica\c c\~ao do efeito de redu\c c~ao de cor para
cruzar as informa\c c\~oes de luminosidade com a cor espec\'ifica do LED a ser detectado pelo algoritmo, respectivamente.

Ap\'os isso feito, \'e armazenado numa Matriz Bin\'aria a regi\~ao do LED, definindo o valor 1 para pixel com
a cor e luminosidade detectada e 0 para n\~ao detectada.

Essa matriz passa por uma sequ\^encia de Eros\~oes e Dilata\c c\~oes at\'e que a regi\~ao principal seja destacada
e os ru\'idos eliminados. Essas opera\c c\~oes ocorrem por interm\'edio de uma matriz chamada de M\'ascara.

Posteriormente, na matriz bin\'aria \'e verificada a quantidade de massas brancas presentes e, caso haja mais de uma,
o LED \'e simplesmente ignorado.

Caso haja apenas uma massa, \'e calculada a m\'edia das posi\c c\~oes x e y onde os pixels est\~ao acesos e \'e devolvida
uma coordenada (x, y) central. Para isso, \'e foi criada uma estrutura chamada Vis\~ao Computacional que armazena
o par ordenado da regi\~ao central do LED, a cor detectada pelo mesmo e faixa de luminosidade que \'e testada no momento
da calibra\c c\~ao da c\^amera pelo algoritmo.

\subsection{Algoritmos utilizados\label{sec:alg}}

\subsubsection{HSV e RGB}
Cada pixel de uma imagem extra\'ida da c\^amera do computador no modelo de cores RGB (Red, Green, Blue) \'e convertido em
HSV / HSB (Hue, Saturation, Value / Brightness), permitindo descobrir o grau da cor pura (Matiz), as faixas representada por cada cor,
a porcentagem de satura\c c\~ao da cor (Pureza) e a porcentagem de brilho (Valor).

O H \'e a matiz e \'e medida em graus compreendendo valores de 0\degree a 359\degree.
A faixa de cada uma das seis cores principais (prim\'arias e secund\'arias) \'e definida numa margem de 60 graus.
As faixas s\~ao classificadas da seguinte maneira: Vermelho (0\degree a 59\degree), Amarelo (60\degree a 119\degree), Verde (120\degree a 179\degree),
Ciano (180\degree a 239\degree), Azul (240\degree a 299\degree) e Magenta (300\degree a 359\degree).
O S \'e a satura\c c\~ao e \'e medida em porcentagem nos valores de 0 a 100\%.
Finalmente, o V \'e o brilho e medido tamb\'em em porcentagem, (0 a 100\%). Como observa\c c\~ao importante, \'e possível notar
que as cores branco e preto s\~ao definidas de acordo com o valor de V: quando se aproxima de 0, emite a cor preta,
e quando se aproxima de 100, branca.

Por exemplo, para reconhecer a luz do LED, \'e poss\'ivel por interm\'edio de uma porcentagem alta
do V (Valor de brilho) e sua cor pela faixa de H (Matiz).

Para manipular essa representa\c c\~ao, foi necess\'ario a cria\c c\~ao de uma estrutura chamada Pixel
que deve armazenar todos os dados de cores de apenas um pixel e a implementa\c c\~ao de dois algoritmos
que compreendem as convers\~oes nos dois sentidos: RGB para HSV e HSV para RGB.

A fim de padronizar, foram implementadas tamb\'em algumas fun\c c\~oes de formata\c c\~ao: convers\~ao de
um valor decimal para porcentagem (S e V), convers\~ao de um grau para um valor de 0 a 5 (H) e convers\~ao
de canais de cores RGB em um valor decimal entre 0 e 1.

Al\'em disso, foram desenvolvidas fun\c c\~oes complementares de m\'aximo e m\'inimo dentre tr\^es valores (R, G e B).

	\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=0.15]{img/HSV_color_solid_cylinder_alpha_lowgamma.png}
		\footnotesize \caption{Representa\c c\~ao tridimensional do espa\c co de cor HSV. Cr\'editos: SharkD. http://en.wikipedia.org/wiki/HSL\_and\_HSV }
	\end{center}
	\end{figure}	


\subsubsection{Escala de cinza}
Os valores RGB de um pixel podem ser convertidos em escala de cinza por uma s\'erie de m\'etodos.
Com esse fim, foi escolhido o m\'etodo de escalas fixas correspondendo a cada um dos canais RGB.
\'E efetuada a seguinte opera\c c\~ao sobre cada pixel:

\texttt{\small \textbf{R} x 0,3 + \textbf{G} x 0,51 + \textbf{B} x 0,18}

\noindent Dessa maneira, cada pixel assume apenas um valor e, ao mesmo tempo, \'e mantida uma escala para cada valor RGB,
levando em considera\c c\~ao a sua maior tonalidade.

	\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=1.0]{img/1200px-Beyoglu_4671_tricolor.png}
		\footnotesize \caption{Convers\~ao de canais de cores para escala de cinza. Cr\'editos: Nevit Dilmen. http://en.wikipedia.org/wiki/Grayscale }
	\end{center}
	\end{figure}	


\subsubsection{Redu\c c\~ao de cores}
A redu\c c\~ao de cores \'e uma t\'ecnica que tem por objetivo facilitar o reconhecimento de uma regi\~ao espec\'ifica,
diminuindo as cores vis\'iveis e tornando uma regi\~ao mais destacada e isolada que as demais.
Para tal, \'e usada a seguinte opera\c c\~ao sobre cada canal RGB:

\texttt{\small Canal = Canal x Fator + Fator / 2}

\noindent sendo o fator um valor inteiro que define a propor\c c\~ao da quantidade cores que se quer diminuir na imagem.
Exemplos de Fatores: 2, 16, 64, 128. Quanto maior o fator, menor a quantidade de cores vis\'iveis.

\subsubsection{Eros\~ao e dilata\c c\~ao}
A Eros\~ao e a Dilata\c c\~ao s\~ao t\'ecnicas de filtragem com o objetivo de reduzir ru\'idos presentes na imagem,
que possam dificultar a detec\c c\~ao de pontos principais na tela.

Os ru\'idos podem ser causados por uma s\'erie de fatores, dentre eles limita\c c\~oes da c\^amera presente no computador
e presen\c ca de pontos isolados na tela que tenham caracter\'isticas similares aos procurados.

A Eros\~ao trata de eliminar os pontos isolados na imagem, os quais n\~ao possuem outros em destaque em sua vizinhan\c ca.

A Dilata\c c\~ao trata de aumentar os pontos isolados na imagem, consistindo no processo contr\'ario da Eros\~ao.

Com uma sequ\^encia razo\'avel de opera\c c\~oes de Eros\~ao e Dilata\c c\~ao, a quantidade de ru\'idos \'e descartada,
ao mesmo passo que a regi\~ao que deve ser destacada \'e mantida em seu tamanho original.

\subsubsection{Controle de massas}
Visando uma defini\c c\~ao exata e correta do ponto central que deve ser devolvido pela fun\c c\~ao da vis\~ao computacional,
foi necess\'ario a implementa\c c\~ao de um mecanismo para ter ideia caso outras massas brancas al\'em da principal (o LED)
est\'a sendo retornada e, com isso, comprometendo a jogabilidade do jogo.

Essa fun\c c\~ao analisa a vizinhan\c ca de cada um dos pixels da imagem contabilizando as massas brancas presentes em tela.

Para isso, \'e criada uma estrutura bidimensional chamada Matriz de V\'ertices, onde cada v\'ertice armazena informa\c c\~oes
relevantes sobre cada pixel: valor definindo se o pixel está aceso (1 - branco) ou apagado (0 - preto) e o numero de massa
definido por uma vari\'avel contadora.

Ao final, o algoritmo retorna um n\'umero inteiro compreendendo a quantidade de massas brancas encontradas.

\section{Simula\c c\~ao da \'arvore}

Adotamos a estrutura de dados de \'arvore tern\'aria para construir a \'arvore do jogo. Essa estrutura \'e basicamente constituida
em pontos de crescimento que se dividem no m\'aximo em tr\^es partes cada um. Essas partes d\~ao origem aos galhos que crescem at\'e
determinado tamanho, decidido aleat\'oriamente. As pontas de cada galho s\~ao novos pontos de crescimento,
que se dividem de novo e d\~ao origem a novos galhos

Para que simula\c c\~ao tenha um aspecto e comportamento mais pr\'oximo de uma \'arvore, elaboramos uma solu\c c\~ao que inclui
a mat\'eria estudada na disciplina de Estrutura de Dados e elaboramos algoritmos para simular o crescimento da \'arvore,
dos galhos e dos frutos. Basicamente a \'arvore cresce de acordo com um valor de energia de crescimento fornecida
a ela logo no in\'icio do jogo. Uma parte dessa energia \'e consumida pelo tronco e o restante \'e distribuido
de maneira aleat\'oria para os pr\'oximos galhos que ir\~ao nascer, de acordo com o seguinte crit\'erio: \\

 \texttt{\footnotesize{\textbf{SE} galho.energiaConsumida == ((galho.energiaLimite * 50) / 100) \textbf{E} galho.temFilhos == FALSO 
        \textbf{ENT\~AO} galho.criarFilhos = SIM}} \\


Isso se repete at\'e que n\~ao haja mais energia suficiente
para repassar ao galho seguinte. O jogador tem a oportunidade de fornecer mais energia ao longo da partida, o que
ir\'a proporcionar uma \'arvore mais desenvolvida e com mais frutos para serem colhidos.

	\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=0.2]{img/PI3_Ponto_Crescimento.png}
		\caption{\footnotesize {Crescimento dos galhos e energia transferida de pai para filho.} }
	\end{center}
	\end{figure}	
	
\subsubsection{Crescimento}
Para que os galhos crescam controladamente mas mantendo certa diferencia\c c\~ao em tamanho e
dire\c c\~ao entre um e outro, estabelecemos um crit\'erio que chamamos de energia de crescimento e energia limite.
A energia limite determina o quanto cada  galho da \'arvore vai crescer e \'e estabelecido atrav\'es de uma porcentagem,
calculada a partir do total de energia de crescimento fornecida para o galho, o n\'ivel de altura desse galho e a energia
limite da \'arvore:

  \texttt{\footnotesize{galho.energiaLimite = (energiaRecebida * (arvore.energiaLimite - (galho.profundidade * 2)) / 100)}}

O valor da energia limite pode
ser alterado de acordo com a intera\c c\~ao do usu\'ario ao longo do jogo, o que pode proporcionar uma \'arvore mais
mais ou menos desenvolvida.

Enquanto os galhos crescem eles podem dar origem a novos galhos. Isso \'e determinado ap\'os ser consumida uma determinada
quantidade de energia de crescimento fornecida ao galho, o que permite que a simula\c c\~ao de crescimento da \'arvore
fique mais natural. A \'unica exce\c c\~ao \'e o tronco da \'arvore, que tem o crescimento
mais controlado:

\texttt{\footnotesize{\textbf{SE} galho.energiaConsumida < galho.energiaLimite \textbf{E} galho.energiaRecebida > 0
\textbf{ENT\~AO} galho.crescer}}

\subsubsection{Pontos de crescimento de frutos e folhas}
Os pontos de crescimento de frutos e folhas s\~ao determinados de acordo com o m\'inimo de energia que o galho
tem para crescer. Caso esse valor seja igual ou abaixo de determinado crit\'erio, o algoritmo de simula\c c\~ao assume
que n\~ao ir\~ao surgir novos galhos a partir do galho atual, ainda durante a fase de crescimento. Com isso determinado,
o galho passa a produzir folhas e frutos ao inv\'es de novas ramifica\c c\~ao de galhos.

	\begin{figure}[ht!]
	\begin{center}
		\includegraphics[scale=0.15]{img/PI3_Arvore.png}
		\footnotesize \caption{Estrutura da \'arvore e pontos de crescimento de frutos e folhas }
	\end{center}
	\end{figure}	

\subsection{Primeiros experimentos}
Para o reconhecimento de uma cor emitida por um LED do Arduino, fizemos uma otimiza\c c\~ao f\'isica
com um peda\c co de papel que reduzisse o brilho da luz, por\'em ainda n\~ao \'e suficiente para
o reconhecimento total.

Como experimentos necess\'arios, temos o reconhecimento da luminosidade para verificar
a proximidade da luz com a c\^amera e uma otimiza\c c\~ao afim de isolar a cor do LED,
ignorando as outras cores similares e aparentes na c\^amera.

\section{Bibliotecas}
\subsection{OpenCV 2.4.11}
OpenCV (Open Source Computer Vision Library)
\'e uma biblioteca de c\'odigo aberto de vis\~ao computacional e aprendizado de m\'aquina,
desenvolvida para dar suporte a aplicativos que requerem processamento de imagens.
  
\subsection{Allegro 5.0}
O Allegro \'e uma biblioteca multiplataforma de programa\c c\~ao voltada para desenvolvimento de jogos. Ela
oferece suporte para programa\c c\~ao baixo n\'ivel em C e C++, ou seja, fornece ferramentas para que o usu\'ario
desenvolva sua pr\'opria programa\c c\~ao de jogo.
\subsection{Arduino-Serial}
Biblioteca de c\'odigo aberto em linguagem de programa\c c\~ao C, que oferece suporte a
comunica\c c\~ao via porta serial do computador com o Arduino.

\section{Equipamentos}
\begin{itemize}
\item C\^amera de captura de v\'ideo
\item Placa controladora Arduino Uno
\item LED RGB
\item Computador (desktop ou notebook)
\end{itemize}

\nocite{*}
\section{Cr\'editos para as imagens}
Figura 

\section{Bibliografia}
\bibliographystyle{sbc}
\bibliography{plantgoshi}


\end{document}
